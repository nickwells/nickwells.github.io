<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-06-12 Sat 18:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Go Recipes - Strings</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Nick Wells" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Go Recipes - Strings</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0d85a42">Strings</a>
<ul>
<li><a href="#orgc42fbe2">Strings one character at a time</a>
<ul>
<li><a href="#orgc511425">Summary</a></li>
<li><a href="#orge29d685">Discussion</a></li>
</ul>
</li>
<li><a href="#orgaa4c9aa">Substrings</a>
<ul>
<li><a href="#orgebda28b">Summary</a></li>
<li><a href="#org8168c75">Discussion</a></li>
<li><a href="#org2b94a57">References</a></li>
</ul>
</li>
<li><a href="#org80321fb">Splitting a string into words</a>
<ul>
<li><a href="#org8e2ba9f">Summary</a></li>
<li><a href="#orgf8bb12d">Discussion</a></li>
<li><a href="#org66bfc83">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org0d85a42" class="outline-2">
<h2 id="org0d85a42">Strings</h2>
<div class="outline-text-2" id="text-org0d85a42">
<p>
These recipes offer some tips for handling Go strings. There are some
excellent Go packages in the standard library, most notably the strings
package but these recipes talk you through some of the subtleties of Go
strings.
</p>

<p>
For other recipes <a href="gorecipes.html">see here</a>.
</p>
</div>
<div id="outline-container-orgc42fbe2" class="outline-3">
<h3 id="orgc42fbe2">Strings one character at a time</h3>
<div class="outline-text-3" id="text-orgc42fbe2">
</div>
<div id="outline-container-orgc511425" class="outline-4">
<h4 id="orgc511425">Summary</h4>
<div class="outline-text-4" id="text-orgc511425">
<p>
If you just want to go through the string from start to end then you can
use a simple range loop, this will present the characters one at a time
as follows:
</p>
<div class="org-src-container">
<pre class="src src-go">s := "Pi: π Pie: tasty"

for i, r := range s {
	fmt.Printf("%2d: %c\n", i, r)
}
fmt.Println()
</pre>
</div>

<p>
If you want random access to the runes (Go's name for a Unicode Code
point) then you need to convert the string to a slice of runes first.
</p>
<div class="org-src-container">
<pre class="src src-go">s := "Pi: π"
r := []rune(s)
fmt.Printf("%c\n", r[4])
</pre>
</div>
</div>
</div>

<div id="outline-container-orge29d685" class="outline-4">
<h4 id="orge29d685">Discussion</h4>
<div class="outline-text-4" id="text-orge29d685">
<p>
Let's establish what we mean by 'character'. In Go a string
is a sequence of bytes but this is not what we are talking about. By
'character' we mean a Unicode Code Point or, as Go calls it, a rune.
</p>

<p>
This is an important distinction but one which native speakers of English
may never be aware of. Go encodes runes using UTF8 which only needs a
single byte for the 128 ASCII characters so most code you see will not
use any non-ASCII characters. Let's look at an example with non-ASCII
characters.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "Pi: π"
fmt.Printf("s: %q\n", s)
fmt.Println("len(       s ):", len(s))
fmt.Println("len([]rune(s)):", len([]rune(s)))
</pre>
</div>

<p>
The string has a Greek letter Pi as it's 5th character. This will print
the string and will show it as having length 6 as a string but only 5 as
a slice of runes.
</p>

<p>
What's happening? There are 6 bytes being used to encode the 5
characters (runes). Let's look inside the string, we'll add a
period at the end of the string to illustrate the difference.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "Pi: π."

for i, r := range s {
	fmt.Printf("[%d]%c 0x%[2]x %08[2]b  ", i, r)
}
fmt.Println()

for i, r := range []rune(s) {
	fmt.Printf("[%d]%c 0x%[2]x %08[2]b  ", i, r)
}
fmt.Println()
</pre>
</div>

<p>
When you run this you will see almost exactly the same results for each
loop but the index values have a gap in them for the loop over the string
but not for the loop over the slice of runes. So let's look at what's
happening in the string.
</p>

<p>
Note that the Printf statements each use the explicit argument index to
reference the character ('ch') three times.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "Pi: π"

fmt.Printf("       s [4]%c 0x%[1]x %08[1]b\n", s[4])
fmt.Printf("       s [5]%c 0x%[1]x %08[1]b\n", s[5])
fmt.Printf("[]rune(s)[4]%c 0x%[1]x %08[1]b\n", []rune(s)[4])
</pre>
</div>

<p>
When you run this to examine the contents of the string at characters 4
and 5 you'll see that you get s[4] shown as Ï and s[5] is a non-printing
character (PAD). This is the UTF8 encoding at work showing the two
characters which together form the UTF8-encoded rune for the Greek letter
pi.
</p>
</div>
</div>
</div>
<div id="outline-container-orgaa4c9aa" class="outline-3">
<h3 id="orgaa4c9aa">Substrings</h3>
<div class="outline-text-3" id="text-orgaa4c9aa">
<p>
Go offers several ways of extracting substrings but you need to
understand strings and how they are encoded to know which is best.
</p>
</div>
<div id="outline-container-orgebda28b" class="outline-4">
<h4 id="orgebda28b">Summary</h4>
<div class="outline-text-4" id="text-orgebda28b">
<p>
To get the last character of a string you will need to convert it into a
slice of runes and then take the last element of that slice as follows:
</p>
<div class="org-src-container">
<pre class="src src-go">s := "Pi: π"
r := []rune(s)
fmt.Printf("r[end] = %c\n", r[len(r)-1])
</pre>
</div>

<p>
To get a substring of the first two characters we can use standard
slicing operations as follows:
</p>
<div class="org-src-container">
<pre class="src src-go">s := "Pi: π"
r := []rune(s)
fmt.Printf("r[:2] = %s\n", string(r[:2]))
</pre>
</div>
<p>
Note that we have to convert the slice of runes back into a string in
order to print it.
</p>
</div>
</div>

<div id="outline-container-org8168c75" class="outline-4">
<h4 id="org8168c75">Discussion</h4>
<div class="outline-text-4" id="text-org8168c75">
<p>
You can take a substring in a number of ways but you need to be aware of
the distinction between bytes and runes. A string is an array of bytes
and the same array slicing techniques can be applied but if a character
is not represented by a single byte then you will need to know how long
it is or else (safer) convert it into a slice of runes and work with
that.
</p>

<p>
What are the downsides of this? There is a cost to constructing the rune
slice; the slice of runes takes up to four times as much space as a
string since potentially each byte in the string will be held as a 4-byte
rune in the slice of runes. If the string has a lot of non-ASCII
characters then the inflation will be less, most European or Middle
Eastern alphabets will see the slice of runes take twice as much space,
strings of Chinese characters will increase in size by a third and
strings of emojis will suffer no increase in size. There is also the
runtime cost of constructing the rune slice out of the string. If you are
just doing this occasionally then you can ignore the cost but if you are
doing it in some high-performance loop you should be aware that
converting strings to slices of runes is not free. Also, be aware that
strings with multi-byte runes will take longer to convert to a rune-slice
than strings holding just single-byte runes (ASCII characters). The more
multi-byte runes the longer it takes but there is an initial cost as soon
as there is even a single multi-byte rune.
</p>
</div>
</div>

<div id="outline-container-org2b94a57" class="outline-4">
<h4 id="org2b94a57">References</h4>
<div class="outline-text-4" id="text-org2b94a57">
<p>
see the standard packages <a href="https://pkg.go.dev/unicode/utf8">unicode/utf8</a>, <a href="https://pkg.go.dev/strings">strings</a> and <a href="https://pkg.go.dev/regexp">regexp</a> and the
Go blog entry by Rob Pike <a href="https://blog.golang.org/strings">Strings, bytes, runes and characters in Go</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-org80321fb" class="outline-3">
<h3 id="org80321fb">Splitting a string into words</h3>
<div class="outline-text-3" id="text-org80321fb">
</div>
<div id="outline-container-org8e2ba9f" class="outline-4">
<h4 id="org8e2ba9f">Summary</h4>
<div class="outline-text-4" id="text-org8e2ba9f">
<p>
The simplest way is to use the Split function from the strings package to
divide the string up around spaces, as follows:
</p>
<div class="org-src-container">
<pre class="src src-go">words := strings.Split("The quality of mercy", " ")
fmt.Printf("%q\n", words)
</pre>
</div>
<p>
A better way, though slower, is to use the regexp package. Like this:
</p>
<div class="org-src-container">
<pre class="src src-go">re := regexp.MustCompile(`\s+`)
words := re.Split("The quality of mercy", -1)
fmt.Printf("%q\n", words)
</pre>
</div>
<p>
Note that you must pass the Split method a final parameter of -1 so that
it will return all the substrings.
</p>
</div>
</div>
<div id="outline-container-orgf8bb12d" class="outline-4">
<h4 id="orgf8bb12d">Discussion</h4>
<div class="outline-text-4" id="text-orgf8bb12d">
<p>
If you have run these code fragments in gosh you will notice that they
both produce the same results so why do I say that the regexp version is
better. To understand this let's take a look at how these approaches work
with a different string. First let's try a string with multiple spaces.
First with the strings version:
</p>
<div class="org-src-container">
<pre class="src src-go">words := strings.Split("The quality of  mercy", " ")
fmt.Printf("%q\n", words)
</pre>
</div>
<p>
And using the regexp version:
</p>
<div class="org-src-container">
<pre class="src src-go">re := regexp.MustCompile(`\s+`)
words := re.Split("The quality of  mercy", -1)
fmt.Printf("%q\n", words)
</pre>
</div>
<p>
If you run these you'll see that the strings version produces an extra,
empty word between "of" and "mercy". Let's try again with another string.
</p>
<div class="org-src-container">
<pre class="src src-go">words := strings.Split("The quality of  mercy\n\tis not strained,\n"+
			"it droppeth as the\n\tgentle rain from heaven", " ")
fmt.Printf("%q\n", words)
</pre>
</div>
<p>
And using the regexp version:
</p>
<div class="org-src-container">
<pre class="src src-go">re := regexp.MustCompile(`\s+`)
words := re.Split("The quality of  mercy\n\tis not strained,\n"+
			"it droppeth as the\n\tgentle rain from heaven", -1)
fmt.Printf("%q\n", words)
</pre>
</div>
<p>
You'll see from these examples that the regexp version does much better
than the strings version but it's still not perfect, it includes the
punctuation at the end of "strained,". We can improve this but we'll
discuss it further when we talk about regular expressions.
</p>

<p>
The disadvantages with the regexp approach are that there's a little more
code needed (an extra line), you need to understand regular expressions
and the Split method is a bit more complicated to use - it's like the
SplitN function from the strings package.
</p>
</div>
</div>
<div id="outline-container-org66bfc83" class="outline-4">
<h4 id="org66bfc83">References</h4>
<div class="outline-text-4" id="text-org66bfc83">
<p>
See the standard packages  <a href="https://pkg.go.dev/strings">strings</a> and <a href="https://pkg.go.dev/regexp">regexp</a>.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Nick Wells</p>
<p class="date">Created: 2021-06-12 Sat 18:01</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
