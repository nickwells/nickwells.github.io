<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-06-11 Fri 23:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Go Recipes - Formatting Output</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Nick Wells" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Go Recipes - Formatting Output</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf143231">Formatting Output</a>
<ul>
<li><a href="#org9af1c81">Custom formatting of data types</a>
<ul>
<li><a href="#orgf316efe">Summary</a></li>
<li><a href="#orgff8f420">References</a></li>
</ul>
</li>
<li><a href="#orge35e6e6">Custom formatting of the Go-syntax representation</a>
<ul>
<li><a href="#org704fe86">Summary</a></li>
<li><a href="#orgf77060e">References</a></li>
</ul>
</li>
<li><a href="#org8badf25">Complete control over formatting</a>
<ul>
<li><a href="#org2fe6117">Summary</a></li>
<li><a href="#org66d66da">References</a></li>
</ul>
</li>
<li><a href="#orgc0861ae">Wrapping text</a>
<ul>
<li><a href="#org5e2ca60">Summary</a></li>
<li><a href="#org20bed07">Discussion</a></li>
<li><a href="#orgdd9f9e0">References</a></li>
</ul>
</li>
<li><a href="#orga32f82c">Tabulating data</a>
<ul>
<li><a href="#org9bf6f55">Summary</a></li>
<li><a href="#orgf2414b8">Discussion</a></li>
<li><a href="#org2f40d8c">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf143231" class="outline-2">
<h2 id="orgf143231">Formatting Output</h2>
<div class="outline-text-2" id="text-orgf143231">
<p>
These recipes offer some tips for formatting Go output. We first dicuss
some less well known features of the standard fmt package and then go on to
discuss some ways of formatting your output that the fmt package doesn't
offer.
</p>

<p>
For other recipes <a href="gorecipes.html">see here</a>.
</p>
</div>
<div id="outline-container-org9af1c81" class="outline-3">
<h3 id="org9af1c81">Custom formatting of data types</h3>
<div class="outline-text-3" id="text-org9af1c81">
</div>
<div id="outline-container-orgf316efe" class="outline-4">
<h4 id="orgf316efe">Summary</h4>
<div class="outline-text-4" id="text-orgf316efe">
<p>
The <a href="http://golang.org/package/fmt">fmt</a> package is the standard tool you should use for formatting output
but you can extend it and tune the behaviour for your own data types. The
simplest way to adjust the output that fmt will produce is to write a
'String' method for your type as follows.
</p>

<div class="org-src-container">
<pre class="src src-go">type Location struct{
      file string
      line int
}

// String returns a string representing the contents of the Location
func (l Location)String() string {
      return l.file + ":" + strconv.Itoa(l.line)
}
</pre>
</div>

<p>
If you are using gosh to run the code you will need to use the 'global'
parameter for the code shown above.
</p>

<p>
Then when you print the value you will see it has been formatted using
the 'String' method.
</p>

<div class="org-src-container">
<pre class="src src-go">l := Location{
      file: "main.go",
      line: 42,
}

fmt.Println("Println:", l)
fmt.Printf("     %%s:  %s\n", l)
fmt.Printf("     %%v:  %v\n", l)
fmt.Printf("     %%+v: %+v\n", l)
fmt.Printf("     %%#v: %#v\n", l)
</pre>
</div>

<p>
Try calling this with and without the String method declared.
</p>

<p>
The String method is a useful way of controlling how your types are
displayed. It is used to produce the output from the formats "%v"
and "%+v" (or "%s").
</p>
</div>
</div>

<div id="outline-container-orgff8f420" class="outline-4">
<h4 id="orgff8f420">References</h4>
<div class="outline-text-4" id="text-orgff8f420">
<p>
see the standard package <a href="https://golang.org/pkg/fmt">fmt</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orge35e6e6" class="outline-3">
<h3 id="orge35e6e6">Custom formatting of the Go-syntax representation</h3>
<div class="outline-text-3" id="text-orge35e6e6">
<p>
The fmt package verb 'v' can also be used to produce a Go-syntax
representation of the value when given a '#' flag. We'll discuss here how
we can control the output in this case.
</p>
</div>

<div id="outline-container-org704fe86" class="outline-4">
<h4 id="org704fe86">Summary</h4>
<div class="outline-text-4" id="text-org704fe86">
<p>
The String method on a type is used, if it exists, by the fmt package to
display a value in a lot of cases. The "%#v" format though will not use
this, to change the way that the Go-syntax representation appears you
need to provide a GoString method for your type. You might want to
provide this method to hide secret credentials so that they don't appear
in log files for instance. For this use case remember that you'll also
need to provide a String method. Also be aware that this is not
sufficient to prevent the secret from being exposed but it might help to
avoid accidental exposure.
</p>

<div class="org-src-container">
<pre class="src src-go">type Secret struct{
      username string
      password string
}

// String returns a string representing the contents of the Secret
func (s Secret)String() string {
      return s.username
}

// GoString returns a string representing the contents of the Secret
// in a Go-syntax representation
func (s Secret)GoString() string {
      return `main.Secret{username:"` + s.username + `", password: "..."}`
}
</pre>
</div>

<p>
Then when you print the value you will see it has been formatted using
the GoString method.
</p>

<div class="org-src-container">
<pre class="src src-go">s := Secret{
      username: "Nick",
      password: "TopSecret",
}

fmt.Println("Println:", s)
fmt.Printf("     %%s:  %s\n", s)
fmt.Printf("     %%v:  %v\n", s)
fmt.Printf("     %%+v: %+v\n", s)
fmt.Printf("     %%#v: %#v\n", s)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf77060e" class="outline-4">
<h4 id="orgf77060e">References</h4>
<div class="outline-text-4" id="text-orgf77060e">
<p>
see the standard package <a href="https://golang.org/pkg/fmt">fmt</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org8badf25" class="outline-3">
<h3 id="org8badf25">Complete control over formatting</h3>
<div class="outline-text-3" id="text-org8badf25">
</div>
<div id="outline-container-org2fe6117" class="outline-4">
<h4 id="org2fe6117">Summary</h4>
<div class="outline-text-4" id="text-org2fe6117">
<p>
If you need complete control over the display of your value you can
provide a Format method. This gives your formatting code access to the
values of the width and precision options and to the flags and the verb
chosen to print. It is the most complicated to use but gives you the most
control over formatting.
</p>

<div class="org-src-container">
<pre class="src src-go">type Secret struct{
      username string
      password string
}

// Format formats a Secret
func (s Secret)Format(f fmt.State, verb rune) {
      switch verb {
      case 'z':
	      fmtStr := "Secret for %"
	      if wid, ok := f.Width(); ok {
		      fmtStr += strconv.Itoa(wid)
	      }
	      if prec, ok := f.Precision(); ok {
		      fmtStr += "." + strconv.Itoa(prec)
	      }
	      fmtStr += "s"
	      f.Write([]byte(fmt.Sprintf(fmtStr, s.username)))
      default:
	      f.Write([]byte("%!"+string(verb)+"(Secret)"))
      }
}
</pre>
</div>

<p>
Then when you print the value you will see it has been formatted using
the Format method. Note that the verb you use does not have to be one of
the standard runes that the fmt package uses.
</p>

<div class="org-src-container">
<pre class="src src-go">s := Secret{
      username: "Nick",
      password: "TopSecret",
}

fmt.Println("Println:", s)
fmt.Printf("     %%z:  %z\n", s)
fmt.Printf("     %%v:  %v\n", s)
fmt.Printf("     %%+v: %+v\n", s)
fmt.Printf("     %%#v: %#v\n", s)
</pre>
</div>

<p>
Note that if a Format method is available it is used for all the value
forms ("%v", "%+v" and "%#v") whereas the String method is only used for
the first two and the GoString method is only used for the last form.
</p>
</div>
</div>

<div id="outline-container-org66d66da" class="outline-4">
<h4 id="org66d66da">References</h4>
<div class="outline-text-4" id="text-org66d66da">
<p>
see the standard package <a href="https://golang.org/pkg/fmt">fmt</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orgc0861ae" class="outline-3">
<h3 id="orgc0861ae">Wrapping text</h3>
<div class="outline-text-3" id="text-orgc0861ae">
</div>
<div id="outline-container-org5e2ca60" class="outline-4">
<h4 id="org5e2ca60">Summary</h4>
<div class="outline-text-4" id="text-org5e2ca60">
<p>
If you have a large block of text that you want to display to the user
you have a problem. The issue is that simply printing it out will mean
that it wraps at random places in the text as the terminal wraps at the
edge of the screen. It might even be truncated at the edge of the screen
depending on the terminal you are using.
</p>

<p>
You can wrap the text yourself by adding newlines at the appropriate
places but that is laborious, tedious and needs to be repeated whenever
you change the text.
</p>

<p>
Alternatively you can use a package to do the wrapping for you.
</p>
</div>
</div>

<div id="outline-container-org20bed07" class="outline-4">
<h4 id="org20bed07">Discussion</h4>
<div class="outline-text-4" id="text-org20bed07">
<p>
There are several text wrapping packages available. I've chosen three and
I'll discuss them in order of complexity. Some of the packages have
similar names and if you are using gosh to try out the examples you might
find that goimports doesn't correctly populate the import statements,
especially if you don't already have the module in your cache. In this
case you can use gosh's "-import" parameter to give the correct package
to import.
</p>
</div>

<ul class="org-ul">
<li><a id="org5a41e02"></a>go-wordwrap<br />
<div class="outline-text-5" id="text-org5a41e02">
<p>
The first package is <a href="https://pkg.go.dev/github.com/mitchellh/go-wordwrap">go-wordwrap</a> (with package name "wordwrap"); this
offers one method: WrapString which simply returns a string wrapped at
word boundaries up to a maximum line length. Like this:
</p>

<div class="org-src-container">
<pre class="src src-go">s := "The quality of mercy is not strained."+
      " It droppeth as the gentle rain from heaven"
fmt.Println(wordwrap.WrapString(s, 30))
</pre>
</div>

<p>
This will split the string into two lines, each no longer than 30
characters. It will only split at word boundaries so if a word is very
long then it may exceed the maximum length.
</p>

<p>
The maximum line length cannot be negative since the parameter is a uint
so your code won't even compile if you try. If you set it to zero then no
wrapping is performed. You might argue that this is a bug since it's not
something you would want.
</p>

<p>
Note that this package is still accepting pull requests but has only seen
minimal changes recently.
</p>
</div>
</li>

<li><a id="orgdd67b61"></a>wordwrap<br />
<div class="outline-text-5" id="text-orgdd67b61">
<p>
The next package is <a href="https://pkg.go.dev/github.com/eidolon/wordwrap">wordwrap</a>; this is a bit more complicated. You first
generate a WrapperFunc and then call it on the strings you want to
wrap. Like this:
</p>

<div class="org-src-container">
<pre class="src src-go">s := "The quality of mercy is not strained."+
      " It droppeth as the gentle rain from heaven"
wrapper := wordwrap.Wrapper(30, false)
fmt.Println(wrapper(s))
</pre>
</div>

<p>
Again the string is split into two lines, each no longer than 30
characters. The advantage of controlling this approach is that you can
just pass the function around and you only need to set the parameters
when you first create it. Unlike with the previous package you can set
the maximum line length to a negative value as it takes an integer
parameter but the code panics if the value is less than one.
</p>

<p>
You can control whether words may be split in the middle by setting the
second parameter (called breakWords) to the Wrapper function.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "A string including a very long word,"+
      " 1234567890123456789012345678901234567890"+
      " and some shorter ones"
wrapperNoBreak := wordwrap.Wrapper(30, false)
fmt.Println(wrapperNoBreak(s))
wrapperBreak := wordwrap.Wrapper(30, true)
fmt.Println(wrapperBreak(s))
</pre>
</div>

<p>
The <a href="https://pkg.go.dev/github.com/eidolon/wordwrap">wordwrap</a> package also offers an Indent function that will add a
prefix to one or all the lines on the given string. The following will
just add the prefix to the first line.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "The quality of mercy is not strained."+
      " It droppeth as the gentle rain from heaven"
wrapper := wordwrap.Wrapper(30, false)
fmt.Println(
      wordwrap.Indent(wrapper(s), "Portia (as Balthazar): ", false))
</pre>
</div>

<p>
And this will add the prefix to every line.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "Some text to be written to a Go program as a comment."+
      " Yet more comment text."
wrapper := wordwrap.Wrapper(30, false)
fmt.Println(
      wordwrap.Indent(wrapper(s), "// ", true))
</pre>
</div>

<p>
Note that this package is not in a module and has not been changed for a
few years.
</p>
</div>
</li>

<li><a id="org5529d32"></a>twrap<br />
<div class="outline-text-5" id="text-org5529d32">
<p>
The last package we'll discuss is <a href="https://pkg.go.dev/github.com/nickwells/twrap.mod/twrap">twrap</a> (for t(ext)wrap); this takes a
different approach and offers much more control over how the text is
wrapped.
</p>

<p>
Like the last package we discussed, to use it you first construct an
object and then call wrapping functions on that. It differs from either
of the other packages in that it writes the text directly rather than
returning a string. You can choose the writer when you create the
wrapper, the default is standard out. Like the first package discussed it
will not split words outside of word boundaries.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "The quality of mercy is not strained."+
      " It droppeth as the gentle rain from heaven"
twc, err := twrap.NewTWConf()
if err != nil {
      fmt.Println("Error creating the TWConf: ", err)
      os.Exit(1)
}
twc.Wrap(s, 30)
</pre>
</div>

<p>
This is a bit long-winded because we have the error checking but you can
call the NewTWConfOrPanic function instead and that will panic on error
instead.
</p>

<p>
Other differences to note are that the Wrap function takes an indent
parameter rather than a maximum line length parameter. The maximum line
length is set once on the TWConf object when you construct it, defaulting
to 80 columns. To get the same behaviour as the previous examples we
would need to write the following code:
</p>

<div class="org-src-container">
<pre class="src src-go">s := "The quality of mercy is not strained."+
      " It droppeth as the gentle rain from heaven"
twc := twrap.NewTWConfOrPanic(twrap.SetTargetLineLen(30))
twc.Wrap(s, 0)
</pre>
</div>

<p>
But twrap can do much more than this.
</p>

<p>
You can have prefixed text.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "The quality of mercy is not strained."+
      " It droppeth as the gentle rain from heaven"
twc := twrap.NewTWConfOrPanic()
twc.WrapPrefixed("Portia (as Balthazar): ", s, 10)
</pre>
</div>

<p>
You can have the first line of a block of text with a different
indentation than the subsequent lines.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "The quality of mercy is not strained."+
      " It droppeth as the gentle rain from heaven"
twc := twrap.NewTWConfOrPanic()
twc.Wrap2Indent(s,
      45, // the first line paragraph indent
      40) // other lines indent
</pre>
</div>

<p>
And you can even have the first line of subsequent paragraphs having a
different indent from the first line of text. The twrap package splits
the supplied text into separate blocks around newline characters, these
blocks form paragraphs with their own, potentially different first line
indentation.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "The quality of mercy is not strained."+
      " It droppeth as the gentle rain from heaven"
twc := twrap.NewTWConfOrPanic()
twc.Wrap3Indent("Label: "+s+"\n"+s+"\n"+s,
      40, // first line indent
      49, // first line paragraph indent
      47) // other line indent
</pre>
</div>

<p>
When printing a line twrap will print repeated white space characters
which can allow for some simple formatting.
</p>

<div class="org-src-container">
<pre class="src src-go">s := "A simple list:\n"+
      "  first item    some text describing the first item\n"+
      "  second item   more text, this time describing the 2nd item\n"+
      "  third item    the end. No more text"
twc := twrap.NewTWConfOrPanic()
twc.Wrap2Indent(s, 40, 50)
</pre>
</div>

<p>
You can also use twrap to print lists (you can change the list prefix
string when you construct the TWConf).
</p>

<div class="org-src-container">
<pre class="src src-go">list := []string {
	"the world",
	"the flesh",
	"and the devil",
}
twc := twrap.NewTWConfOrPanic()
twc.List(list, 10)
</pre>
</div>

<p>
Or indexed lists.
</p>

<div class="org-src-container">
<pre class="src src-go">list := []string {
	"the world",
	"the flesh",
	"and the devil",
}
twc := twrap.NewTWConfOrPanic()
twc.IdxList(list, 10)
</pre>
</div>

<p>
Lastly, this package is in a Go module and is actively maintained.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgdd9f9e0" class="outline-4">
<h4 id="orgdd9f9e0">References</h4>
<div class="outline-text-4" id="text-orgdd9f9e0">
<p>
see <a href="https://pkg.go.dev/github.com/nickwells/twrap.mod/twrap">twrap</a>, <a href="https://pkg.go.dev/github.com/mitchellh/go-wordwrap">go-wordwrap</a> and <a href="https://pkg.go.dev/github.com/eidolon/wordwrap">wordwrap</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orga32f82c" class="outline-3">
<h3 id="orga32f82c">Tabulating data</h3>
<div class="outline-text-3" id="text-orga32f82c">
</div>
<div id="outline-container-org9bf6f55" class="outline-4">
<h4 id="org9bf6f55">Summary</h4>
<div class="outline-text-4" id="text-org9bf6f55">
<p>
Tables are a standard way of showing information especially when you have
a lot of data to report. So how can you build tables in Go? As is often
the case, the Go standard library has something you can use but there are
other packages available as well.
</p>

<p>
I'll discuss two packages, <a href="https://golang.org/pkg/text/tabwriter/">tabwriter</a> from the standard library and the
<a href="http://pkg.go.dev/github.com/nickwells/col.mod/v3/col">col</a> package. Although they both will print tables they take a very
different approach and offer very different interfaces.
</p>
</div>
</div>

<div id="outline-container-orgf2414b8" class="outline-4">
<h4 id="orgf2414b8">Discussion</h4>
<div class="outline-text-4" id="text-orgf2414b8">
</div>
<ul class="org-ul">
<li><a id="org7c1095a"></a>tabwriter<br />
<div class="outline-text-5" id="text-org7c1095a">
<p>
The tabwriter package provides a filter that you can write to and that
will pad its output into columns defined by tabs in the input. Let's
look at a quick example.
</p>

<div class="org-src-container">
<pre class="src src-go">lines := []string{
	"The quality\tof mercy\tis not strained\n",
	"It droppeth\tas the gentle rain\tfrom heaven\n",
	"Upon\tthe place\tbeneath\n",
}
tw := tabwriter.NewWriter(
	os.Stdout, //output
	0,         // min width
	1,         // tabwidth
	1,         // padding
	' ',       // padding character
	0)         // flags
for _, l := range lines {
	tw.Write([]byte(l))
}
// tabwriter buffers output so you must call Flush when you finish
tw.Flush()
</pre>
</div>

<p>
The tabwriter package offers some tweaks to its behaviour through the
flags and the other parameters you can give. For instance, increasing
the padding value gives more space between the columns of text.
</p>
</div>
</li>

<li><a id="org5dd2207"></a>col<br />
<div class="outline-text-5" id="text-org5dd2207">
<p>
The col package is more complicated than tabwriter but it can do a lot
more. It takes a very different approach.
</p>

<p>
There are two core structures and a single interface that col is built
around, these are a Report, a Col and a Formatter. You construct the
report from columns and a column has a formatter for displaying the data
and one or more strings for the column header. You need to specify the
column width and the data type of each column. Once you have constructed
the Report, you can print the data. Repeatedly call the PrintRow method
passing the values to be printed. The type of the values should match
the types expected by the formatter for the corresponding column. Let's
see an example.
</p>

<div class="org-src-container">
<pre class="src src-go">rpt := col.StdRpt(
	col.New(colfmt.Int{W:4}, "year"),
);
rpt.PrintRow(2019)
rpt.PrintRow(2020)
rpt.PrintRow(2021)
</pre>
</div>

<p>
This will print this single column of year numbers. Not so exciting but
now let's add a column.
</p>

<div class="org-src-container">
<pre class="src src-go">rpt := col.StdRpt(
	col.New(colfmt.Int{W: 4}, "year"),
	col.New(colfmt.Int{W: 2}, "number of pupils"),
);
rpt.PrintRow(2019, 34)
rpt.PrintRow(2020, 36)
rpt.PrintRow(2021, 29)
</pre>
</div>

<p>
That looks OK but the number of pupils column title is very wide for the
data so let's put it on two rows.
</p>

<div class="org-src-container">
<pre class="src src-go">rpt := col.StdRpt(
	col.New(colfmt.Int{W: 4}, "year"),
	col.New(colfmt.Int{W: 2}, "number of","pupils"),
);
rpt.PrintRow(2019, 34)
rpt.PrintRow(2020, 36)
rpt.PrintRow(2021, 29)
</pre>
</div>

<p>
That looks better but now let's break down the number of pupis by gender.
</p>

<div class="org-src-container">
<pre class="src src-go">rpt := col.StdRpt(
	col.New(colfmt.Int{W: 4}, "year"),
	col.New(colfmt.Int{W: 2}, "number of pupils", "total"),
	col.New(colfmt.Int{W: 2}, "number of pupils", "male"),
	col.New(colfmt.Int{W: 2}, "number of pupils", "female"),
);
rpt.PrintRow(2019, 34, 18, 16)
rpt.PrintRow(2020, 36, 18, 18)
rpt.PrintRow(2021, 29, 13, 16)
</pre>
</div>

<p>
Now we see one of the useful features of col, title spanning. This is
where adjacent columns sharing parts of the column name have the shared
parts spanned, this leads to a more compact table.
</p>

<p>
One last example, demonstrating another Formatter.
</p>

<div class="org-src-container">
<pre class="src src-go">rpt := col.StdRpt(
	col.New(colfmt.Int{W: 4}, "year"),
	col.New(colfmt.Int{W: 2}, "number of pupils", "total"),
	col.New(colfmt.Int{W: 2}, "number of pupils", "male"),
	col.New(colfmt.Int{W: 2}, "number of pupils", "female"),
	col.New(colfmt.WrappedString{W: 30}, "class motto"),
);
rpt.PrintRow(2019, 34, 18, 16, "Death or Glory")
rpt.PrintRow(2020, 36, 18, 18, "The quality of mercy is not strained,"+
      " it droppeth as the gentle rain from heaven")
rpt.PrintRow(2021, 29, 13, 16, "Whatever!")
</pre>
</div>

<p>
There are several standard formatters provided but you can write your
own provided that it satisfies the Formatter interface.
</p>

<p>
This barely scratches the surface of what you can do with the col
package. If you are looking for a way to format tables of data to a
terminal this is worth investigating.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org2f40d8c" class="outline-4">
<h4 id="org2f40d8c">References</h4>
<div class="outline-text-4" id="text-org2f40d8c">
<p>
see <a href="http://pkg.go.dev/github.com/nickwells/col.mod/v3/col">col</a> and <a href="https://golang.org/pkg/text/tabwriter/">tabwriter</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Nick Wells</p>
<p class="date">Created: 2021-06-11 Fri 23:44</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
